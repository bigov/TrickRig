
=== Преобразование трехмерных координат в координаты камеры ===

Если координаты камеры (x, y, z), то преобразование позиции точки в мировой
системе координат будет (-x, -y, -z). Камера расположена в мировой СК с
использованием перемещения, основанного на векторе (x, y, z) поэтому, что бы
поместить ее в начало координат, необходимо преобразование, обратное данному.
матрица преобразования:

  1  0  0 -Cx
  0  1  0 -Cy
  0  0  1 -Cz
  0  0  0  1

Для преобразования координат точки из мировой системы в систему координат
произвольно повернутой камеры используются матрица поворота, создаваемая из
трех векторов, описывающих позицию камеры:

U - направление из камеры вправо (соответствует X координате камеры)
V - направление из камеры вверх ( Y камеры )
N - вектор от камеры к ее цели. Так же известен как вектор 'look at' в 
    литературе о 3D. Этот вектор соответствует Z оси камеры.

    матрица поворота:    Ux  Uy  Uz  0
                         Vx  Vy  Vz  0
                         Nx  Ny  Nz  0
                         0   0   0   1

Перенос 3D координат точки D(x, y, z) в координаты камеры D(xc, yc, zc)-

                   | Ux  Uy  Uz  0 |   | Dx |   | Dxc |
                   | Vx  Vy  Vz  0 | * | Dy | = | Dyc |
                   | Nx  Ny  Nz  0 |   | Dz |   | Dzc |
                   | 0   0   0   1 |   | 1  |   |  1  |


Нормализация вектора
---------------------
Vector3f& Vector3f::Normalize()
{
    const float Length = sqrtf(x * x + y * y + z * z);
 
    x /= Length;
    y /= Length;
    z /= Length;
 
    return *this;
}

Пересечение вектора (x, y, z) с вектором v(x.y.z)
(используется для нахождения векторов камеры )
-------------------------------------------------
Vector3f Vector3f::Cross(const Vector3f& v) const
{
    const float _x = y * v.z - z * v.y;
    const float _y = z * v.x - x * v.z;
    const float _z = x * v.y - y * v.x;
 
    return Vector3f(_x, _y, _z);
}

// Вычисление матрицы поворота
//
// Функция получает вектор направления и верхний вектор. Вектор вправо
// вычисляется как их векторное произведение. Заметим, что мы хотим нормировать
// векторы в любом случае, даже если они уже единичной длины. После генерации
// вектор вверх пересчитывается как векторное произведение между векторами
// направления и вектором вправо.
-------------------------------------------------
void Matrix4f::InitCameraTransform(const Vector3f& Target, const Vector3f& Up)
{
    Vector3f N = Target;
    N.Normalize();
    Vector3f U = Up;
    U.Normalize();
    U = U.Cross(Target);
    Vector3f V = N.Cross(U);
 
     m[0][0] = U.x; m[0][1] = U.y; m[0][2] = U.z; m[0][3] = 0.0f;
     m[1][0] = V.x; m[1][1] = V.y; m[1][2] = V.z; m[1][3] = 0.0f;
     m[2][0] = N.x; m[2][1] = N.y; m[2][2] = N.z; m[2][3] = 0.0f;
     m[3][0] = 0.0f;m[3][1] = 0.0f;m[3][2] = 0.0f;m[3][3] = 1.0f;
}


