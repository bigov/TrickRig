<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="False" name="TrickRig" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="1">
		<rich_text>
</rich_text>
		<rich_text foreground="#1e1e9090ffff" scale="h2" weight="heavy">Многопользовательское трехмерное игровое пространство</rich_text>
		<rich_text>

• развивать свои (своего героя) способности (в нескольких направлениях), дающих преимущества (по отношению к  другим участникам, нежитям).
• развивать поселение, которое будет приносить бонусы
• возможности творческой самореализации, достижения в которой будут видны другим участникам, и при положительной оценке приносить бонусы.

</rich_text>
		<rich_text background="#bfbfbfbfbfbf" family="monospace" style="italic"> - Функционал переключения режима творческий/приключение как в “MC”     
 - Классно бы было использовать OpenStreetmaps для генерации территорий 
</rich_text>
		<rich_text>
</rich_text>
		<rich_text foreground="#1e1e9090ffff" scale="h3" weight="heavy">Должно присутствовать</rich_text>
		<rich_text>

1. Возможность развиваться и получать более продвинутый инвентарь для лучшей защиты, нападения, развития, сохранения достижений

2. Система торговли

3. Ресурсы для оплаты возможностей:  энергия, очки опыта, игровая валюта для обмена.

4. Возможность приобретать ценности(ресурсы) или длинно - кропотливым трудом, или быстрее при развитии технологий, или в обмен на ресурсы.

5. Опасности для создаваемого окружения, для жизни и уровней способностей, достижениям.

6. Возможность привлекать сущности для постройки, развития и поддержания созданного окружения.

7. Возможность приобретать за игровую валюту фичи и ачивки

8. Можно добавить красивую 3D анимацию на замедленные батальные сцены.

9. Атаки монстров. Разбить на несколько категорий: по земле тяжелая, скоростная, медленная, прямая и т. д. С воздуха — чтобы можно было уворачиваться, прятаться, отражать. Например — скоростная тяжелая черепаха разбивается о неожиданно появившееся препятствие.

10. Продумать тему ипользования как безопасных/ручных, так и опасных монстров (энергии их атаки) для более эффективного добывания ресурсов.


</rich_text>
		<rich_text foreground="#1e1e9090ffff" scale="h3" weight="heavy">Симбионт/фамильяр</rich_text>
		<rich_text>
Сопровождающий персонаж/партнер (симбионт-фея/фамильяр). Вначале она может просто давать советы. 

Влияние на развивитие симбионта по специализациям - например:
		- защита,
		- атака,
		- строительство,
		- исследования, и т.д. и т.п.
Выбор и усиление одной специализации должен ослаблять возможности в другой специализации.

Добавить необходимость заботы о своей фее:
	- оберегать от опасностей,
	- обеспечивать энергией/едой.
	- развивать специализацию.
</rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="ссылки" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="2">
			<rich_text>
проработка примеров из
		</rich_text>
			<rich_text link="webs http://www.tomdalling.com/blog/category/modern-opengl/">http://www.tomdalling.com/blog/category/modern-opengl/</rich_text>
			<rich_text>
		
</rich_text>
			<rich_text style="italic">ОБЛАЧНОЕ ХРАНИЛИЩЕ</rich_text>
			<rich_text>
</rich_text>
			<rich_text link="webs https://developers.openshift.com/">https://developers.openshift.com/</rich_text>
			<rich_text> масштабируемое с бесплатным начальным планом решение. Я там зарегистрирован как ЯнМа+ЦЕпп

Матрицы и квантерионы
</rich_text>
			<rich_text link="webs http://www.rossprogrammproduct.com/translations/Matrix%20and%20Quaternion%20FAQ.htm#Q1">http://www.rossprogrammproduct.com/translations/Matrix%20and%20Quaternion%20FAQ.htm#Q1</rich_text>
			<rich_text>

Подборка уроков по OpenGL
</rich_text>
			<rich_text link="webs http://en.wikibooks.org/wiki/OpenGL_Programming">http://en.wikibooks.org/wiki/OpenGL_Programming</rich_text>
			<rich_text>

</rich_text>
			<rich_text family="monospace" link="webs http://www.lighthouse3d.com/tutorials/glsl-tutorial/" scale="h2" weight="heavy">lighthouse3d.com</rich_text>
			<rich_text>
(!Домен не разрешается через ns Транстелекома!)\
Большая подборка информации и примеров
    - GLSL 1.2 Tutorial подробно про шэйдеры на C:  </rich_text>
			<rich_text link="webs http://www.lighthouse3d.com/tutorials/glsl-tutorial/">http://www.lighthouse3d.com/tutorials/glsl-tutorial/</rich_text>
			<rich_text>
    - </rich_text>
			<rich_text link="webs http://www.lighthouse3d.com/very-simple-libs/vsfl/">отрисовка шрифтов через шейдер</rich_text>
			<rich_text>


Русский перевод уроков по современному OpenGL с сайта OGLDev
    </rich_text>
			<rich_text link="webs https://triplepointfive.github.io/ogltutor/">https://triplepointfive.github.io/ogltutor/</rich_text>
			<rich_text>
    
    
Мультимедийная библиотека: </rich_text>
			<rich_text link="webs http://www.xine-project.org/about">http://www.xine-project.org/about</rich_text>
			<rich_text>
Free, fast, portable and re-usable. xine is a free (gpl-licensed) high-performance, portable and reusable multimedia playback engine. xine itself is a shared library with an easy to use, yet powerful API which is used by many applications for smooth video playback and video processing purposes.

OpenSceneGraph </rich_text>
			<rich_text link="webs http://www.openscenegraph.org">http://www.openscenegraph.org</rich_text>
			<rich_text>  
кроссплатформенная библиотека с открытыми исходниками для разработки высокопроизводительных 3D-приложений. Это не игровой движок, связывающий пользователя по рукам и ногам заложенными в него ограничениями, а именно библиотека — набор полезных модулей, которые отлично работают как поодиночке, так и в сборке.
Вводная статья на Хабре: </rich_text>
			<rich_text link="webs https://habrahabr.ru/post/200890/">https://habrahabr.ru/post/200890/</rich_text>
			<rich_text>

MyGUI </rich_text>
			<rich_text link="webs http://mygui.info/">http://mygui.info/</rich_text>
			<rich_text>
кроссплатформенная библиотека для создания графических интерфейсов

</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="СПРАВКА" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="7">
			<rich_text>
</rich_text>
			<rich_text scale="h3">Библиотека заметок</rich_text>
			<rich_text> 

</rich_text>
			<rich_text scale="h3" weight="heavy">OpenGL &amp; C++</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="node 12 Прямой вывод  на экран пикселей">Прямой вывод  на экран пикселей</rich_text>
			<rich_text>

</rich_text>
			<rich_text link="node 12 Переключение между 2D и 3D">Переключение между 2D и 3D</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="библиотеки" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="3">
				<rich_text>
- для организации сетевой игры ENet </rich_text>
				<rich_text link="webs http://enet.bespin.org/Features.html">http://enet.bespin.org/Features.html</rich_text>
				<rich_text>
- для работы со звуком - OpenAL

</rich_text>
				<rich_text foreground="#a5a52a2a2a2a" justification="center" scale="h1">GUI (интерфейс управления)</rich_text>
				<rich_text>

для формирования интерфейса управления выбор библиотеки из перечня:
		* CEGUI: </rich_text>
				<rich_text link="webs http://cegui.org.uk/,">http://cegui.org.uk/,</rich_text>
				<rich_text>
		* libRocket: </rich_text>
				<rich_text link="webs http://librocket.com/,">http://librocket.com/,</rich_text>
				<rich_text> </rich_text>
				<rich_text link="webs http://mdqinc.com/blog/2013/01/integrating-librocket-with-sdl-2/">http://mdqinc.com/blog/2013/01/integrating-librocket-with-sdl-2/</rich_text>
				<rich_text>
		* Agar: </rich_text>
				<rich_text link="webs http://www.hypertriton.com/agar/docs/gui-intro/index.html.fr.">http://www.hypertriton.com/agar/docs/gui-intro/index.html.fr.</rich_text>
				<rich_text>
		* guichan: </rich_text>
				<rich_text link="webs https://code.google.com/archive/p/guichan/">https://code.google.com/archive/p/guichan/</rich_text>
				<rich_text>


</rich_text>
				<rich_text foreground="#1e1e9090ffff" scale="h2" weight="heavy">FLTK</rich_text>
				<rich_text>

</rich_text>
				<rich_text link="webs https://ru.wikipedia.org/wiki/FLTK">https://ru.wikipedia.org/wiki/FLTK</rich_text>
				<rich_text>
fltk.org — официальный сайт FLTK

	Кросс-платформенная библиотека использует свои собственные независимые системы виджетов, графики и событий, что позволяет писать программы одинаково выглядящие и работающие на разных операционных системах. В отличие от других подобных библиотек (Qt, GTK+, wxWidgets) FLTK ограничивается только графической функциональностью.  Поэтому она имеет малый размер и обычно компонуется статически (это исключение из лицензии GNU Lesser General Public License, разрешенное разработчиками). FLTK не использует сложных 	макросов, препроцессоров и продвинутых возможностей языка C++ (шаблоны, 	исключения, пространства имен).  Вкупе с малым размером кода, это облегчает использование библиотеки не очень искушенными пользователями.


</rich_text>
				<rich_text foreground="#1e1e9090ffff" scale="h2" weight="heavy">FOX toolkit</rich_text>
				<rich_text>

</rich_text>
				<rich_text link="webs https://ru.wikipedia.org/wiki/FOX_toolkit">https://ru.wikipedia.org/wiki/FOX_toolkit</rich_text>
				<rich_text>
</rich_text>
				<rich_text link="webs http://www.fox-toolkit.org/screenshots.html">http://www.fox-toolkit.org/screenshots.html</rich_text>
				<rich_text>

	Кросс-платформенная библиотека инструментов с открытым исходным кодом 	(лицензия LGPL) для построения графического интерфейса пользователя.

	Один из самых быстрых пакетов, содержит большое число элементов GUI и поддержку OpenGL. Язык разработки — C++, существуют привязки к Ruby, Python, Eiffel.


</rich_text>
				<rich_text foreground="#a5a52a2a2a2a" justification="center" scale="h1">Базы данных</rich_text>
				<rich_text>

</rich_text>
				<rich_text foreground="#1e1e9090ffff" scale="h2" weight="heavy">WhiteDB</rich_text>
				<rich_text>

</rich_text>
				<rich_text link="webs http://whitedb.org/index.html">http://whitedb.org/index.html</rich_text>
				<rich_text> Pure speed  lightweight NoSQL database library </rich_text>
				<rich_text weight="heavy">WhiteDB</rich_text>
				<rich_text> written in C, operating fully in main memory. There is </rich_text>
				<rich_text style="italic">no server process.</rich_text>
				<rich_text> </rich_text>
				<rich_text style="italic">Data is read and written directly from/to shared memory</rich_text>
				<rich_text>, no sockets are used between WhiteDB and the application program. 

</rich_text>
				<rich_text foreground="#1e1e9090ffff" scale="h2" weight="heavy">Sophia</rich_text>
				<rich_text>

</rich_text>
				<rich_text link="webs http://sophia.systems/v2.1/index.html">http://sophia.systems/v2.1/index.html</rich_text>
				<rich_text>

СУБД рассчитана на обеспечение очень большой скорости записи и чтения при работе с данными небольшого и среднего размера. Данные сохраняются на диске с использованием лог-подобного хранилища, работающего в режиме постоянного пополнения (append-only). В отличие от других лог-подобных хранилищ, метод хранения в Sophia не ограничивается высокой скоростью записи, но также оптимизирован для обеспечения высокой скорости произвольного чтения данных и выборки диапазонов значений.

</rich_text>
				<rich_text style="italic">Поддерживаются технологии:</rich_text>
				<rich_text>

Дисковое хранение — для хранения используется жесткий диск или Flash-память. Запись кешируется в памяти для последующего сброса на диск.
Анти-кеширование — оперативная память становится основным хранилищем. Холодные данные читаются с диска или Flash-памяти.
Постоянное кеширование — Второе хранилище используется в паре как LRU-кеш в оперативной или Flash-памяти для горячих данных. Холодные и горячие данные дублируются в основном хранилище.
Постоянное хранение в памяти — данные хранятся в оперативной памяти и постоянно сохраняются на диске. Поддерживается сжатие данных в памяти.

</rich_text>
				<rich_text style="italic">Основные особенности СУБД Sophia:</rich_text>
				<rich_text>

 - Быстрая запись (Append-Only) и оптимизация на чтение;
 - Соответствие требованиям ACID (атомарность, согласованность, изолированность, надежность);
 - MVCC-движок для обеспечения одновременного конкурентного доступа к БД (Multi-Version Concurrency Control);
 - Транзакции, которые могут охватывать несколько операций;
 - Консистентные курсоры;
 - Снапшоты;
 - Возможность хранения нескольких БД в одном файле;
 - Поддержка сериализированных представлений;
 - Многопоточный движок и возможность использования в многопоточных приложениях;
 - Поддержка создания горячих бэкапов, создаваемых на лету без приостановки работы;
 - Простой API, лёгкая интеграция с приложениями, отсутствие сторонних зависимостей. Для работы требуется только два файла на языке Си.
</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="OpenGL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1515814228.14" unique_id="8">
				<rich_text>
</rich_text>
				<rich_text scale="h3" weight="heavy">Настройка текстур:</rich_text>
				<rich_text>

Если используется опция GL_CLAMP_TO_BORDER, то можно настроить цвет границы:

    float b_color[] = { 0.0f, 1.0f, 0.0f, 1.0f };
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, b_color);
    
Группа текстур:
    1. вначале назначают:
    
    	  GLuint m_textureObj;
		    glGenTextures(1, &amp;m_textureObj);
		    glActiveTexture(GL_TEXTURE0); // индекс текстуры (можно загрузить не меньше 48)
		    glBindTexture(GL_TEXTURE_2D, m_textureObj);

    2. потом при рендере подключают в шейдере:
     
       	GLint nTx = 0; // индекс текстуры
		    glUniform1i(glGetUniformLocation(prog.get_id(), &quot;texture_0&quot;), nTx);


</rich_text>
				<rich_text weight="heavy">Наименования параметров материалов</rich_text>
				<rich_text>
	GL_AMBIENT  фоновый всенаправленный свет
	GL_DIFFUSE  рассеянный свет
	GL_SPECULAR отраженный свет
	GL_EMISSION излучаемый свет
	GL_SHININESS степень отраженного света

</rich_text>
				<rich_text weight="heavy">Пример настройки Отражающих свойств материала</rich_text>
				<rich_text>
	glMaterialfv(GL_FRONT, GL_SHININESS, ((GLfloat * 4)(1.0, 0.0, 0.0, 1.0)))
	glMaterialfv(GL_FRONT, GL_SPECULAR, ((GLfloat * 4)(1.0, 0.0, 0.0, 1.0)))
	glMaterialfv(GL_FRONT, GL_DIFFUSE, ((GLfloat * 4)(0.2, 0.2, 0.2, 1.0)))

</rich_text>
				<rich_text weight="heavy">Ночной свет (без теней)</rich_text>
				<rich_text>
glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat * 4)(0.3, 0.3, 0.6, 1.0))

</rich_text>
				<rich_text weight="heavy">В начале запуска программы:</rich_text>
				<rich_text>
    glViewport(0,0, window.width, window.height)    #Reset The Current Viewport
    glEnable(GL_NORMALIZE)
    glDepthFunc(GL_ALWAYS)  #один из двух: GL_ALWAYS | GL_LESS
    glEnable(GL_STENCIL_TEST)
    glEnable(GL_MULTISAMPLE_ARB)

</rich_text>
				<rich_text weight="heavy">Отбраковка обратных полигонов</rich_text>
				<rich_text>
    glFrontFace(GL_CCW);
    glCullFace(GL_BACK);
    glEnable(GL_CULL_FACE);

</rich_text>
				<rich_text weight="heavy">Чего-по про прозрачные тени</rich_text>
				<rich_text>
Clear stencil buffer with zero, increment by one whenever anybody draws into it. When stencil function is enabled, only write where stencil value is zero. This prevents the transparent shadow from drawing over itself
glStencilOp(GL_INCR, GL_INCR, GL_INCR)
glClearStencil(0)
glStencilFunc(GL_EQUAL, 0x0, 0x01)

</rich_text>
				<rich_text weight="heavy">Настройка прозрачности</rich_text>
				<rich_text>
# the opengl blending faq: </rich_text>
				<rich_text link="webs http://www.opengl.org/resources/faq/technical/transparency.htm">http://www.opengl.org/resources/faq/technical/transparency.htm</rich_text>
				<rich_text>
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
glBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_DST_ALPHA) 

</rich_text>
				<rich_text weight="heavy">Туман </rich_text>
				<rich_text>
blends a fog color with each rasterized pixel fragment's post-texturing color.

def setup_fog():
    glEnable(GL_FOG)
    # blending factor. GL_LINEAR | GL_EXP
    glFogi(GL_FOG_MODE, GL_LINEAR)
    # Set the fog color.
    glFogfv(GL_FOG_COLOR, (GLfloat * 4)(0.5, 0.69, 1.0, 1.0))
    glFogf(GL_FOG_DENSITY, 1.0)
    # Say we have no preference between rendering speed and quality.
    glHint(GL_FOG_HINT, GL_DONT_CARE)
    
    # How close and far away fog starts and ends. The closer the start and end,
    # the denser the fog in the fog range.
    glFogf(GL_FOG_START, 20.0)
    glFogf(GL_FOG_END, 60.0)
</rich_text>
				<node custom_icon_id="0" foreground="" is_bold="False" name="версии GLSL" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="9">
					<rich_text>

Соответствие версий

</rich_text>
					<rich_text family="monospace" weight="heavy"> GLSL		OpenGL</rich_text>
					<rich_text family="monospace">
-------------
	1.30				3.0
	1.40				3.1
	1.50				3.2
	3.30				3.3
	4.00				4.0
	4.10				4.1
	4.20				4.2
	4.30				4.3
	4.40				4.4
	4.50				4.5
</rich_text>
				</node>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="ОБЩИЕ ИДЕИ" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1516012014.83" unique_id="10">
			<rich_text>
Логика построения трехмерного виртуального пространства

- получить из хранилища данные элемента в указанной точке (rig) пространства
- геометрию (snip) элемента передать в VBO для рендера
- физику - в движок обсчета физики


</rich_text>
			<rich_text weight="heavy">о выборе шага сетки ригов</rich_text>
			<rich_text>

При угле зрения 60 град. длина видимой стороны на нормальной к камере плоскости, увеличивается прямо пропорционально увеличению расстояния до камеры, с коэффициентом = 1,1547. Это значит, что (привязываясь к неизменному числу пикселей на экране монитора):

если на расстоянии от камеры (например)=10м используется сетка ригов с шагом (например) =1м, то на расстоянии =20м  можно уже использовать сетку ригов с шагом =2м; на расстоянии 40м - шаг 4м, и так далее. При этом заметной потери качества отображения не должно произойти!

Через  8 (всего!) последовательных удвоений выходим на дистанцию в 5 тысяч единиц.


</rich_text>
			<rich_text scale="h2">ПОДРОБНО</rich_text>
			<rich_text>

</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Радиус рендера LOD0 = 25 ригов (квадрат 51х51)

Из (файлового) хранилища в контейнер в оперативной памяти загружается и постоянно там находится область размером 128х128 ригов. При перемещении области LOD0 (на примере вверх - красная стрелка) по ходу движения подгружается полоса 128x32 (вверху рисунка коричневая сетка без заливки), а полоса позади (бледно-зеленая заливка внизу) удаляется из памяти. 

Подгрузка данных происходт в момент пересечения задней границей области LOD0 средней (осевой) линии активной области размером 128х128. Т.е. когда вся область LOD0 оказывается полностью на одной половине хранящейся в контейнере в оперативной памяти области 128х128 риг.

После получения команды на выполнение операции подгрузки данных, контрольной осевой линией (по которой срабатывает тригер подгрузки) становится следующая по ходу движения граница, расположеная через 32 рига вперед от предыдущей. Т.е. снова осевая линия вновь построеной области 128х128.

Кстати, неплохая идея - насчет переноса активной границы срабатывания. Надо будет пересмотреть логику работы при перестройке границ (realc_borders) рендера. В настоящее время она работает по центральной точке расположения камеры. Неплохо было бы ее сместить чуть назад отнсительно направления движения.</rich_text>
			<encoded_png char_offset="879">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</encoded_png>
			<node custom_icon_id="0" foreground="" is_bold="False" name="виртуальное пространство" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1516012014.83" ts_lastsave="1516099722.32" unique_id="6">
				<rich_text background="#ffffffffffff" foreground="#1a1a1a1a1a1a">

      Разрабатываемый графический движок предназначен для симуляции взаимодействия с окружением в открытом/замкнутом пространстве на поверхности (при постоянном наличии силы тяжести). Технически это обозначает, что в любой точке виртуального пространства всегда существует не менее одной поверхности по вертикальной координате (Y).  Следовательно, в базе данных можно реализовать хранение данных о структуре виртуального пространства в системе координат 2+1.</rich_text>
				<rich_text> Это значит следующее:

- Таблица `</rich_text>
				<rich_text weight="heavy">snips</rich_text>
				<rich_text>` содержит нормированые по размеру данные снипов: `id_snip`, `data` (BLOB). Полностью загружается в память.

- Таблица `</rich_text>
				<rich_text weight="heavy">tricks</rich_text>
				<rich_text>` - группировка снипов. Поля: `ids_snip`, `trick`(номер группы). Полностью загружается в память. К отдельному ригу привязывается индекс группы.

- Таблица `</rich_text>
				<rich_text weight="heavy">rigs</rich_text>
				<rich_text>` - положение триков (как групп снипов) в 3d координатах. Поля: `trick`, `ids_xz`, `y`, данные рига. Уникальный ключ по сочетанию полей (`ids_xz`, `y`), так как в каждой точке виртуального 3d пространства можно расположить строго не более одного трика.

- Таблица `</rich_text>
				<rich_text weight="heavy">xzs</rich_text>
				<rich_text>` - координаты на плоскости X-Z. Cвязана с таблицей `rigs` по индексу `id_xz`. Уникальный ключ по сочетанию (`x`, `z`).

- При описании однородных вертикальных структур несколько строк таблицы `rigs`, с разными значениями `y`, указывают на одну строку таблицы `xys` и одинаковый индекс группы снипов.

    Это дает возможность производить выборку данных о строении пространства по двум координатам и эффективно принимать решение о необходимости генерации поверхности в конкретном &quot;столбике&quot; на (X, Z) при отсутствии записи в базе данных.

    Кроме того, при хранении однородных вертикальных структур можно существенно экономить память, связывая необходимое количество ссылок на трики через таблицу ригов с координатами расположения &quot;столбика&quot; (X, Z) и нужными значениями по Y.

</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="база данных" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1515815296.59" unique_id="4">
				<rich_text>
</rich_text>
				<rich_text scale="h1">ПОСТРОЕНИЕ БАЗЫ ДАННЫХ</rich_text>
				<rich_text>

 1. Данные снипов записывать в нормализованом виде - отнимать координаты рига,
     в котором снип располагается. Кроме прочего, это позволит сжимать таблицу
     снипов, удаляя одинаковые группы поверхностей и задавая в таблице ригов
     адреса id_area на общие группы. При этом следует, при предоставлении доступа
     на изменение формы поверхности рига, создавать перед началом изменения
     копию его группы снипов, чтобы не редактировать одновременно все зависимые
     риги (с аналогичными группами).

     Если по такому-же принципу строить карту (std::map) ригов, данные из которой
     передаются на рендер в VBO, то можно неплохо экономить оперативную память для
     хранения данных карты.

 2. При загрузке данных снипа в лист рига, соответственно, прибавлять вектор рига
     к координатам вершин снипа.

 3. В риге ввести 2 переменные:
      1) Вектор смещения снипа относительно базовой точки координат рига. Но умолчанию
          он будет нулевым, но позволит использовать снипы нестандартного размера и
          двигать их произвольно внутри рига.
      2) Вектор поворота: рыскание (yaw), тангаж (pitch), крен (roll). Это позволит
          произвольно поворачивать отдельные предметы на поверхности.


</rich_text>
				<rich_text scale="h1">ОБЩИЕ ИДЕИ</rich_text>
				<rich_text>

В базе данных хранить информация о

	- пространстве
	- размещение объектов
	- индекс объекта
	- координаты:
			x, y, z - точка в пространстве
			yaw, pit, rol - рыскание (yaw), тангаж (pitch), крен (roll)
			t	- временная фаза

	- клиентах
		- положение в пространстве
		- текущие параметры
		- наличие инвентаря

	- объектах (библиотека объектов)
		- уникальный индекс
		- форма,
		- поверхность (шейдер)
		- изменение во времени
			При наличии свойства объекта изменяться во времени тут храним
			- индекс объекта, в который превращается нестабильный объект
			- продолжительность стабильной фазы объекта

			
</rich_text>
				<rich_text weight="heavy">Таблица ригов</rich_text>
				<rich_text>: id; x; y; z; born
</rich_text>
				<rich_text weight="heavy">Таблица снипов</rich_text>
				<rich_text>: id; rig_id; 56 float (BLOB), 

CREATE TABLE rigs ( id INTEGER PRIMARY KEY, x INTEGER, y INTEGER, z INTEGER, born INTEGER);
CREATE TABLE snips ( id INTEGER PRIMARY KEY, rig INTEGER, snip BLOB);</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="сервер-цифры" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1515813698.09" unique_id="11">
				<rich_text>
Для базы данных на территории размером 20.000.000 x 20.000.000 x 40.000
Максимальное количество элементов составит 16.000.401.600.040.040.000

Для хранения ключей используется тип “unsigned long long”
максимально возможное значение типа  18.446.744.073.709.551.615

Стоит проверить идею:
	индексы блоков разбить на чанки для использования 32-битных индексов вместо 64-битных. В этом случае база будет состоять из 4.294.967.295 блоков по 4.294.967.295 элементов

32-битный индекс может адресовать куб элементов со стороной 1625

При обмене данными между сервером и клиентом использует трехмерные координаты.</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="клиент-сервер логика" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1515814128.22" unique_id="5">
				<rich_text>
</rich_text>
				<rich_text foreground="#a5a52a2a2a2a" scale="h2" weight="heavy">Взаимодействие элементов приложения</rich_text>
				<rich_text>

</rich_text>
				<rich_text weight="heavy">Инициализация</rich_text>
				<rich_text>
открытие локальных файлов, чтение настроек, создание GUI.

</rich_text>
				<rich_text weight="heavy">Идентификация клиента</rich_text>
				<rich_text>
по локальному ключу

</rich_text>
				<rich_text weight="heavy">Подключение к серверу</rich_text>
				<rich_text> (локальному или внешнему)
• клиент-&gt;серверу:
   ◇ проверка совместимости,
   ◇ идентификация по локальному ключу
   ◇ аутентификация
• сервер:
   ◇ поиск записи в базе данных о текущем положении и состоянии клиента
   ◇ ---&gt;клиенту:
      ▪ передача начальных координат
      ▪ наличия инвентаря
      ▪ текущего состояния и характеристик клиента
• клиент:
   ◇ установка состояния по данным от сервера
   ◇ ---&gt;серверу:
      ▪ запрос данных по пространству
• сервер-&gt;клиенту:
   ◇ очередь с потоком данных окружения
• клиент:
   ◇ рендеринг пространства по данным с сервера
   ◇ &lt;-обмен-&gt; с сервером:
   ◇ опрос структуры пространства,
   ◇ очередь запросов на внесение изменений в пространство

</rich_text>
				<rich_text scale="h2" weight="heavy">Обмен данными</rich_text>
				<rich_text>
</rich_text>
				<rich_text weight="heavy">1. Подключение.</rich_text>
				<rich_text>
Сервер устанавливает положение клиента и передает ему в потоке все элементы куба видимости.

</rich_text>
				<rich_text weight="heavy">2. Связь</rich_text>
				<rich_text>.
Клиент запрашивает координаты 4D (точка в пространстве + временная метка с разрешением 0.01сек),
сервер по этим координатам передает 0, если изменений нет или индекс элемента, если произошло изменение в данной точке координат.

На запрос клиента (по индексу) точки в пространстве, сервер отвечает что в этой точке есть:
   ◇ глобальный индекс элемента. Младшие разряды индекса выделить на:
      ▪ ориентация или поворот (три младших бита 0-7= 8 положений)
      ▪ временная фаза или состояние объекта (еще 3 бита = 4 стадии роста + 4 стадии разрушения)
      ▪ остается 2 бита - индикаторы
        Соответственно, индекс элемента должен быть выровнен по границе 256 (8 бит)
	
	По индексу элемента клиент в своем локальном кэше находит описание структуры элемента и строит его в пространстве графического буфера. Если такого элемента в кэше у клиента нет, то делается дополнительный запрос к серверу на получение описания элемента.

	Аналогично, клиент может передавать серверу описания собственных элементов, индексы которых на сервере отсутствуют, через запрос на добавление. Сервер может принять описание нового элемента и разместить его в базе данных, а при наличии ошибок в описании отклонить.
</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="CPP" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1515559923.68" unique_id="15">
			<rich_text></rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="CLANG" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="18">
				<rich_text>
</rich_text>
				<rich_text weight="heavy">Улучшения в Clang 5.0:</rich_text>
				<rich_text>

    Поддержка расширения для использования сопрограмм в коде на C++ (</rich_text>
				<rich_text link="node 17">пример кода</rich_text>
				<rich_text>). Для включения следует использовать опции «-fcoroutines-ts -stdlib=libc++»;
    Обеспечена полная поддержка стандарта C++17. Для активации режима C++17 следует использовать флаг «-std=c++17» («-std=c++1z» оставлен для обеспечения совместимости);

    Новые возможности для диагностики:
        «-Wcast-qual» для проверки корректности приведения типов в Си-стиле для C++;
        «-Wunused-lambda-capture» для выявления переменных, захваченных лямбда-выражением, но не используемых в теле лямбда-выражения;
        «-Wstrict-prototypes» для выявления не-прототипных функций, определений блоков и типов в Си и Objective-C;
        «-Wunguarded-availability» для информирования об использовании новых API, которые были представлены в системе, версия которой новее версии системы, заданной в качестве целевой. Также добавлен сокращённый вариант «-Wunguarded-availability-new», который охватывает проверку версий API, выпущенных после macOS 10.13, iOS 11, tvOS 11 и watchOS 4;
        «-Wdocumentation» — позволяет использовать в комментариях директивы
        param и returns для задания типа указателя для блока или функции;

    Добавлен новый флаг компилятора «—autocomplete» для вывода списка флагов и их аргументов для применения в системах автодополнения ввода;
    Объявлены устаревшими и игнорируются флаги «-fslp-vectorize-aggressive» (заменён нормальным векторизатором SLP) и
    «-fno-slp-vectorize-aggressive» (данное поведение теперь всегда используется по умолчанию);

    Добавлена новая pragma attribute для применения атрибута к нескольким декларациям;
    Для языков Си++ и Си реализовано GNU-расширение для неявного скалярного преобразования в вектор. Пример преобразования скалярного значения в вектор (ко всем элементам вектора «a» будет прибавлено 5):

</rich_text>
				<rich_text family="monospace">       typedef unsigned v4i32 __attribute__((vector_size(16)));
       v4i32 foo(v4i32 a) {
          return a + 5;
       }
</rich_text>
				<rich_text>
    В clang-format добавлена опция BreakBeforeInheritanceComma для подстановки разрывов после «:» и «,» при определении класса. Опция включена по умолчанию при выборе стиля оформления кода Mozilla. Обеспечено выравнивание комментариев. Обеспечена автоматическая подстановка комменария с именем пространства имён в конце его определения;

       class MyClass
           : public X
           , public Y {
       };

       /* line 1
        * line 2
        */

       namespace A {
          int i;
          int j;
       } // namespace A




</rich_text>
				<node custom_icon_id="0" foreground="" is_bold="False" name="сопрограммы С++" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="0.0" unique_id="17">
					<rich_text>

В Clang 5.0 добавлена поддержка расширения для использования сопрограмм в коде на C++. Для включения следует использовать опции «-fcoroutines-ts -stdlib=libc++»;
Описание расширения: </rich_text>
					<rich_text link="webs http://open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf">http://open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf</rich_text>
					<rich_text>
Пример кода: </rich_text>
					<rich_text link="webs https://wandbox.org/permlink/Dth1IO5q8Oe31ew2">https://wandbox.org/permlink/Dth1IO5q8Oe31ew2</rich_text>
					<rich_text> 


</rich_text>
					<rich_text family="monospace">#include &lt;iostream&gt;
#include &lt;experimental/coroutine&gt;
​
struct generator {
  struct promise_type;
  using handle = std::experimental::coroutine_handle&lt;promise_type&gt;;
  struct promise_type {
    int current_value;
    auto get_return_object() { return generator{handle::from_promise(*this)}; }
    auto initial_suspend() { return std::experimental::suspend_always{}; }
    auto final_suspend() { return std::experimental::suspend_always{}; }
    void unhandled_exception() { std::terminate(); }
    void return_void() {}
    auto yield_value(int value) {
      current_value = value;
      return std::experimental::suspend_always{};
    }
  };
  bool move_next() { return coro ? (coro.resume(), !coro.done()) : false; }
  int current_value() { return coro.promise().current_value; }
  generator(generator const&amp;) = delete;
  generator(generator &amp;&amp; rhs) : coro(rhs.coro) { rhs.coro = nullptr; }
  ~generator() { if (coro) coro.destroy(); }
private:
  generator(handle h) : coro(h) {}
  handle coro;
};

generator f() { co_yield 1; co_yield 2; }

int main() {
  auto g = f();
  while (g.move_next()) std::cout &lt;&lt; g.current_value() &lt;&lt; std::endl;
}</rich_text>
					<rich_text>

Опции компиляции:
    $ clang++ prog.cc -Wall -Wextra -std=c++1z &quot;-fcoroutines-ts&quot; &quot;-stdlib=libc++&quot;</rich_text>
				</node>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Прямой вывод пикселей" prog_lang="custom-colors" readonly="False" tags="C++" ts_creation="0.0" ts_lastsave="0.0" unique_id="12">
				<rich_text>
</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text scale="h2">Прямой вывод  на экран пикселей
</rich_text>
				<rich_text>(в режиме RGBA с возможностью масштабирования)

</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>
</rich_text>
				<encoded_png anchor="Прямой вывод  на экран пикселей" char_offset="1">anchor</encoded_png>
				<codebox char_offset="82" frame_height="340" frame_width="90" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="cpp" width_in_pixels="False">
void Scene::draw_marker(void)
{
	gl::RasterPos2i((cfg.gui.w - cursor.w)/2, (cfg.gui.h - cursor.h)/2);

	// Можно масштабировать изображение, например увеличить вдвое:
	int fW = cursor.w;
	int fH = cursor.h;
	float zoomX = 2.f, zoomY = 2.f;
	fW = cursor.w * static_cast&lt;int&gt;(zoomX);
	fH = cursor.h * static_cast&lt;int&gt;(zoomY);
	gl::PixelZoom(zoomX, zoomY);
	gl::RasterPos2i((cfg.gui.w - fW)/2, (cfg.gui.h - fH)/2);

	gl::DrawPixels(cursor.w, cursor.h, gl::RGBA,
		gl::UNSIGNED_BYTE, cursor.d());

	//Если масштабировали, то в конце следует вернуть исходный масштаб = 1х1
	gl::PixelZoom(1.f, 1.f);

	return;
}</codebox>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Переключение 2D-3D" prog_lang="custom-colors" readonly="False" tags="C++" ts_creation="0.0" ts_lastsave="0.0" unique_id="16">
				<rich_text>
</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text scale="h2">Переключение между 3D и 2D режимами</rich_text>
				<rich_text>

</rich_text>
				<rich_text justification="left"></rich_text>
				<encoded_png anchor="Переключение между 2D и 3D" char_offset="1">anchor</encoded_png>
				<codebox char_offset="39" frame_height="575" frame_width="90" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="cpp" width_in_pixels="False">
void Scene::set_ortho(void)
{
 	// set viewport to be the entire window
 	gl::Viewport(0, 0, cfg.gui.w, cfg.gui.h);

 	// set orthographic viewing frustum
	gl::MatrixMode(gl::PROJECTION);
	gl::LoadIdentity();
		
	gl::Ortho(0, cfg.gui.w, 0, cfg.gui.h, -1, 1);

	// switch to modelview matrix in order to set scene
	gl::MatrixMode(gl::MODELVIEW);
	gl::LoadIdentity();

	return;
}

void Scene::set_3d(void)
{
	// set viewport to be the entire window
	gl::Viewport(0, 0, cfg.gui.w, cfg.gui.w);

	// set perspective viewing frustum
	gl::MatrixMode(gl::PROJECTION);
	gl::LoadIdentity();

	GLfloat ratio = 
		static_cast&lt;float&gt;(cfg.gui.w)/static_cast&lt;float&gt;(cfg.gui.w);
	gl::Frustum(-ratio, ratio, -1.f, 1.f, 1.f, 500.f);

	// switch to modelview matrix in order to set scene
	gl::MatrixMode(gl::MODELVIEW);
	gl::LoadIdentity();
	return;
}
</codebox>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Попиксельный вывод" prog_lang="custom-colors" readonly="False" tags="" ts_creation="0.0" ts_lastsave="1515559910.15" unique_id="14">
				<rich_text>
Пример использования (устаревший функционал) попиксельного вывода на экран для отрисовки текста и создания курсора. В функции использован объект переменная-член &quot;font_map&quot;

</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>

Формирование курсора в центре экрана и отрисовка текстовой строки:

</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>

</rich_text>
				<codebox char_offset="174" frame_height="315" frame_width="90" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="cpp" width_in_pixels="False">//
// Вывод на экран текста в режиме 2D 
// 
// !! glRasterPos2d - УСТАРЕВШИЙ ФУНКЦИОНАЛ !!
//
void Scene::draw_wstring(int x, int y, const std::wstring &amp; ws)
{
	for(auto k: ws)
	{
		tr::fntImg _ch = font_map.chars[k];
		if(_ch.x &gt; 0)
		{
			gl::RasterPos2d(x + _ch.left, y - (_ch.h - _ch.top));
			gl::DrawPixels(_ch.w, _ch.h, gl::RGBA, gl::UNSIGNED_BYTE, _ch.d());
			x += _ch.x/64;
    	}
	}
	return;
}
</codebox>
				<codebox char_offset="245" frame_height="705" frame_width="90" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="cpp" width_in_pixels="False">//
// Отображение курсора и текста в &quot;ортогональном&quot; 2D окне
// 
// glMatrixMode - УСТАРЕВШИЙ ФУНКЦИОНАЛ
//
void Scene::draw_2d_content(void)
{
    int // размеры окна экрана
    	gui_w = tr::Config::get_w(),
		gui_h = tr::Config::get_h();

	gl::MatrixMode(gl::PROJECTION);
	gl::LoadIdentity();
	gl::Ortho(0, gui_w, 0, gui_h, 0, 1);

	// Изображение курсора (прицела)
	// -----------------------------
#define d0 200, 200, 200, 255,
#define d1  94,  94,  94, 255,
	GLubyte dot[] = {
		d1 d1 d0 d1 d1
		d1 d0 d0 d0 d1
		d0 d0 d1 d0 d0
		d1 d0 d0 d0 d1
		d1 d1 d0 d1 d1
	};
#undef d0
#undef d1		
	//  Вариант 1: нарисовать курсор припомощти маасива - пиксельной маски 5x5
	gl::RasterPos2i(gui_w/2 - 1, gui_h/2 - 1);
	gl::DrawPixels(5, 5, gl::RGBA, gl::UNSIGNED_BYTE, dot);

	//  Вариант 2 - из текстурки &quot;cursor&quot;
	//gl::RasterPos2i((gui.w - cursor.w)/2, (gui.h - cursor.h)/2);
	//gl::DrawPixels(cursor.w,cursor.h,gl::RGBA,gl::UNSIGNED_BYTE,cursor.d());

    // Отображение текстовой строки
	draw_wstring(10, 10, L&quot;0123456789 Тестовая строка %!?*.@#$&quot;);

	return;
}

</codebox>
			</node>
		</node>
	</node>
</cherrytree>
